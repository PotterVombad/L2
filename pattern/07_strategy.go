package pattern


//паттерн Стратегия это поведенческий паттерн, выносит набор алгоритмов 
//в собственные классы и делает их взаимозаменимыми.
//Другие объекты содержат ссылку на объект-стратегию и делегируют ей работу. 
//Программа может подменить этот объект другим, если требуется иной способ решения задачи.

//Использование паттерна может решить эти проблемы:
//-Когда есть семейство родственных алгоритмов: Используется, когда есть несколько алгоритмов, выполняющих схожие действия, 
//и можно выделить их общие черты.
//-Когда нужна возможность выбора алгоритма во время выполнения: Используется, когда клиентскому коду требуется 
//динамически выбирать алгоритм в зависимости от контекста.
//-Когда есть необходимость избегать множественных условных операторов: Используется, 
//когда необходимо избежать множественных условных операторов, что улучшает читаемость кода.

// Плюсы:
// -Гибкость и расширяемость: Код становится более гибким и расширяемым, поскольку новые стратегии могут быть 
//добавлены или существующие изменены без влияния на клиентский код.
//-Избегание условных операторов: Помогает избежать большого количества условных операторов, 
//что улучшает читаемость и поддерживаемость кода.
//-Изоляция алгоритмов: Каждая стратегия инкапсулируется в своем классе, что упрощает изменение или расширение функциональности.

// Минусы:
// -Увеличение числа классов: Внедрение множества стратегий может привести к увеличению числа классов,
//что может усложнить структуру проекта.
//-Клиент должен знать о стратегиях: Клиентский код должен знать о существующих стратегиях и быть способен выбирать между ними.

import "fmt"

// Интерфейс стратегии
type Strategy interface {
	ExecuteStrategy()
}

// Конкретная стратегия A
type ConcreteStrategyA struct{}

func (s *ConcreteStrategyA) ExecuteStrategy() {
	fmt.Println("Executing ConcreteStrategyA")
}

// Конкретная стратегия B
type ConcreteStrategyB struct{}

func (s *ConcreteStrategyB) ExecuteStrategy() {
	fmt.Println("Executing ConcreteStrategyB")
}

// Контекст, использующий стратегию
type Context struct {
	strategy Strategy
}

func (c *Context) SetStrategy(strategy Strategy) {
	c.strategy = strategy
}

func (c *Context) Execute() {
	if c.strategy != nil {
		c.strategy.ExecuteStrategy()
	} else {
		fmt.Println("No strategy set")
	}
}