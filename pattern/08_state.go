package pattern

//паттерн Состояние это поведенческий паттерн, 
//позволяющий динамически изменять поведение объекта при смене его состояния.
//Поведения, зависящие от состояния, переезжают в отдельные классы. 
//Первоначальный класс хранит ссылку на один из таких объектов-состояний и делегирует ему работу.

//Использование паттерна может решить эти проблемы:
//-Объект должен изменять свое поведение при изменении своего внутреннего состояния.
//-Поведение, зависящее от состояния, должно определяться независимо. 
//То есть добавление новых состояний не должно влиять на поведение существующих состояний.

//Использование паттерна описывает следующее решение:
//-Определите отдельные объекты (состояния), которые инкапсулируют поведение, 
//зависящее от состояния, для каждого состояния. То есть определите интерфейс (состояние) для выполнения поведения, 
//зависящего от состояния, и определите классы, реализующие интерфейс для каждого состояния.
//-Класс делегирует поведение, зависящее от состояния, своему текущему объекту состояния вместо прямой реализации поведения, 
//зависящего от состояния.

// Плюсы:
// -Разделение ответственностей: Паттерн помогает разделить ответственности и поведение объекта на набор классов, 
//каждый из которых представляет одно состояние.
//-Управление переходами: Обеспечивает простой механизм для управления переходами между состояниями, делая систему более гибкой.
//Легкость добавления новых состояний: Добавление новых состояний и изменение поведения объекта становится относительно простым.

// Минусы:
// -Увеличение числа классов: Введение новых классов для каждого состояния может привести к увеличению числа классов в системе.
// -Комплексность дизайна: Неопытные разработчики могут столкнуться с трудностями в понимании 
//концепций и в правильном выборе состояний.

import "fmt"

// Интерфейс состояния
type State interface {
	Handle()
}

// Конкретное состояние A
type ConcreteStateA struct{}

func (s *ConcreteStateA) Handle() {
	fmt.Println("Handling in State A")
}

// Конкретное состояние B
type ConcreteStateB struct{}

func (s *ConcreteStateB) Handle() {
	fmt.Println("Handling in State B")
}

// Контекст
type ContextStruct struct {
	state State
}

func (c *ContextStruct) SetState(state State) {
	c.state = state
}

func (c *ContextStruct) Request() {
	c.state.Handle()
}